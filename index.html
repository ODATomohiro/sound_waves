<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Oscillo Lab.</title>
  <style>
    :root{
      --bg:#0c0f14; --panel:#121722; --panel-2:#0f1420; --brand:#4dd0e1; --accent:#7c4dff;
      --text:#ffffff; --muted:#dfe6ee;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:radial-gradient(1200px 800px at 70% -10%,#1c2435 0%,#0c0f14 60%);color:var(--text);
         font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,"Noto Sans JP",sans-serif;letter-spacing:.02em;display:flex;flex-direction:column}
    #app{display:flex;min-height:0;flex:1}
    #sidebar{width:430px;background:linear-gradient(180deg,#0d121c,#0a0e15);border-right:1px solid #1b2637;padding:12px;overflow:auto}
    #main{flex:1;display:flex;flex-direction:column;min-width:0}
    header{display:flex;gap:10px;align-items:center;justify-content:space-between;padding:10px 12px;border-bottom:1px solid #1b2637}
    header .title{display:flex;align-items:center;gap:10px;font-weight:800;letter-spacing:.05em}
    header .title img{height:34px;opacity:.95}
    header .right{display:flex;gap:8px;align-items:center}
    button{appearance:none;border:0;border-radius:10px;padding:8px 12px;color:#fff;background:#1a2333;cursor:pointer;font-weight:800;text-shadow:0 1px 2px rgba(0,0,0,0.8)}
    button:hover{filter:brightness(1.12)}
    .btn-primary{background:linear-gradient(135deg,var(--brand),var(--accent));color:#fff}
    canvas{flex:1;display:block;background:linear-gradient(180deg,#0b1018,#0a0f14);cursor:crosshair}
    .card{background:linear-gradient(180deg,#0e1420,#0b111a);border:1px solid #1b2637;border-radius:14px;padding:12px;margin:10px 0}
    .card h3{margin:0 0 10px;font-size:15px;color:#fff;border-bottom:1px solid #1b2637;padding-bottom:6px}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin:6px 0}
    .row > *{flex:0 0 auto}
    label{font-size:12px;color:var(--muted)}
    select,input[type="number"],input[type="text"]{background:#0d1220;border:1px solid #203046;border-radius:10px;padding:6px;color:#fff}
    input[type="range"]{accent-color:#6de;cursor:pointer}
    input[type="number"].wide{width:120px}
    .small{font-size:12px;color:var(--muted)}
    #log{font-size:12px;background:#000;border:1px solid #1b2637;border-radius:10px;padding:8px;max-height:140px;overflow:auto;color:#0f0}
    .muted{opacity:.85}
    .hide{display:none}
    footer{border-top:1px solid #1b2637;padding:8px 12px;text-align:right;color:#cfd6e6;opacity:.8}
    .subtle{color:#cfe7ff90;font-size:12px;margin-top:4px}
    .monoGrid{display:grid;grid-template-columns:1fr 120px;gap:8px;align-items:center}
    fieldset{border:1px solid #1b2637;border-radius:10px;padding:8px;margin:8px 0}
    legend{padding:0 6px;color:#cfe7ffcc}
  </style>
</head>
<body>
  <div id="app">
    <div id="sidebar">
      <div class="card">
        <h3>🎤 録音＋発音（同時記録）</h3>
        <div class="row">
          <label>種類</label>
          <select id="comboType">
            <option value="pulse">理想パルス</option>
            <option value="noise">短いホワイトノイズ</option>
            <option value="osc">オシレーター</option>
          </select>
        </div>
        <div class="row combo-common">
          <label>発音長さ(ms)</label>
          <input id="comboDurMs" type="number" value="200" step="1" min="1">
          <label>音量</label>
          <input id="comboGain" type="range" min="0" max="1" step="0.01" value="0.9">
        </div>

        <fieldset id="comboOscPanel">
          <legend>⚙ オシレーター設定（録音＋発音）</legend>
          <div class="row">
            <label>波形</label>
            <select id="comboOscWave">
              <option value="sine" selected>正弦波</option>
              <option value="square">矩形波</option>
              <option value="triangle">三角波</option>
              <option value="sawtooth">のこぎり波</option>
            </select>
          </div>
          <div class="row">
            <label>周波数(20–600Hz)</label>
            <input type="range" id="comboOscFreqSlider" min="20" max="600" step="1" value="440">
            <label>振動数（周波数）</label>
            <input type="number" id="comboOscFreqInput" class="wide" value="440" step="1" title="600Hz超はこの数値が優先されます">
          </div>
          <div class="small">※ 種類が「オシレーター」のときに使用します（表示は常時）。</div>
        </fieldset>

        <div class="row">
          <label>事前待機(ms)</label>
          <input id="comboPreMs" type="number" value="200" step="10" min="0">
          <label>事後(ms)</label>
          <input id="comboPostMs" type="number" value="500" step="10" min="0">
        </div>
        <div class="row">
          <button id="btnCombo" class="btn-primary">▶ 録音→発音→停止</button>
        </div>
        <div class="row">
          <label><input id="chkShowRec" type="checkbox"> 録音結果を表示</label>
        </div>
        <div class="small">左クリック＝マーカー／右ドラッグ＝ズーム／右クリックorダブルクリック＝ズーム解除。軸はズームに追従。</div>
      </div>

      <div class="card">
        <h3>🔴 録音（手動）</h3>
        <div class="row">
          <button id="btnRec">⏺ Start</button>
          <button id="btnSave" disabled>💾 Save</button>
        </div>
      </div>

      <div class="card">
        <h3>🔊 発音（単独）</h3>
        <div class="row">
          <button id="btnPulse">Pulse</button>
          <button id="btnNoise">Noise</button>
        </div>
        <div class="row">
          <label>長さ(ms)</label><input id="impMs" type="number" value="20" step="1" min="1">
          <label>音量</label><input id="impGain" type="range" min="0" max="1" step="0.05" value="0.9">
        </div>
      </div>

      <div class="card">
        <h3>🎵 オシレーター（単独）</h3>
        <div class="row">
          <label><input type="checkbox" id="stereoMode"> ステレオモード（デフォルトOFF）</label>
        </div>

        <div id="monoControls" class="monoGrid">
          <div>
            <label>波形</label>
            <select id="oscWave">
              <option value="sine" selected>正弦波</option>
              <option value="square">矩形波</option>
              <option value="triangle">三角波</option>
              <option value="sawtooth">のこぎり波</option>
            </select>
          </div>
          <div></div>
          <div>
            <label>周波数(20–600Hz)</label>
            <input type="range" id="oscFreqSlider" min="20" max="600" step="1" value="440">
          </div>
          <div>
            <label>振動数（周波数）</label>
            <input type="number" id="oscFreqInput" class="wide" value="440" step="1" title="600Hz超はこの数値が優先されます">
          </div>
        </div>

        <div id="stereoControls" class="hide">
          <div class="row"><strong>左チャンネル</strong>　<label><input type="checkbox" id="enableL" checked> ON</label></div>
          <div class="row">
            <label>波形</label>
            <select id="oscWaveL">
              <option value="sine" selected>正弦波</option>
              <option value="square">矩形波</option>
              <option value="triangle">三角波</option>
              <option value="sawtooth">のこぎり波</option>
            </select>
          </div>
          <div class="row">
            <label>周波数(20–600Hz)</label>
            <input type="range" id="oscFreqL" min="20" max="600" step="1" value="440">
            <label>振動数（周波数）</label>
            <input type="number" id="oscFreqInputL" class="wide" value="440" step="1">
          </div>

          <div class="row" style="margin-top:8px;"><strong>右チャンネル</strong>　<label><input type="checkbox" id="enableR" checked> ON</label></div>
          <div class="row">
            <label>波形</label>
            <select id="oscWaveR">
              <option value="sine" selected>正弦波</option>
              <option value="square">矩形波</option>
              <option value="triangle">三角波</option>
              <option value="sawtooth">のこぎり波</option>
            </select>
          </div>
          <div class="row">
            <label>周波数(20–600Hz)</label>
            <input type="range" id="oscFreqR" min="20" max="600" step="1" value="444">
            <label>振動数（周波数）</label>
            <input type="number" id="oscFreqInputR" class="wide" value="444" step="1">
          </div>

          <div class="row">
            <div class="subtle">ビート周波数：<span id="beatHz">—</span> Hz</div>
          </div>
        </div>

        <div class="row">
          <label>音量</label>
          <input type="range" id="oscGain" min="0" max="1" step="0.01" value="0.5">
        </div>
        <div class="row">
          <button id="btnOscStart" class="btn-primary">▶ Start</button>
          <button id="btnOscStop">⏹ Stop</button>
        </div>
      </div>

      <div class="card">
        <h3>表示 / スケール</h3>
        <div class="row">
          <button id="btnWave" class="btn-primary">Waveform</button>
          <button id="btnFFT">FFT</button>
          <button id="btnFull">⤢ Fullscreen</button>
        </div>
        <div class="row">
          <label><input id="chkAxes" type="checkbox" checked> 軸表示</label>
          <label><input id="chkAutoNorm" type="checkbox"> 波形を自動正規化</label>
        </div>
        <div class="row">
          <label>入力ゲイン</label><input id="rangeGain" type="range" min="0.2" max="5" value="1" step="0.1">
        </div>
        <div class="row">
          <label>表示スケール（最大値）</label>
          <input id="displayMax" type="range" min="0.1" max="2.0" step="0.05" value="1.0">
          <span class="small" id="displayMaxLabel">1.00</span>
        </div>
        <div class="row">
          <label>時間窓(秒)</label><input id="rangeTime" type="range" min="0.02" max="0.5" value="0.25" step="0.01">
        </div>
        <div class="row">
          <label><input id="cycleMode" type="checkbox"> 周期基準表示</label>
          <label>表示周期数</label><input id="cycleCount" type="number" value="5" min="1" max="20" class="wide">
        </div>
      </div>

      <div class="card">
        <h3>⏱ トリガー（周期固定＋平均）</h3>
        <div class="row">
          <label><input id="chkTrigger" type="checkbox"> トリガーモード</label>
        </div>
        <div class="row">
          <label>トリガーレベル</label>
          <input id="triggerLevel" type="range" min="-1" max="1" step="0.01" value="0">
          <span class="small" id="triggerLabel">0.00</span>
        </div>
        <div class="row">
          <label>平均化周期数</label>
          <input id="avgCycles" type="range" min="1" max="10" step="1" value="1">
          <span class="small" id="avgLabel">1 周期</span>
        </div>
        <div class="small">上昇エッジ基準で位相固定。平均化でノイズ低減。</div>
      </div>

      <div class="card">
        <h3>📏 マーカー計測（音速）</h3>
        <div class="row">
          <span class="small">Waveform表示時：左クリックで A/B。ダブルクリックでリセット。</span>
        </div>
        <div class="row">
          <label>A(s)</label><input id="markA" type="text" readonly value="—">
          <label>B(s)</label><input id="markB" type="text" readonly value="—">
          <label>Δt</label><input id="deltaT" type="text" readonly value="—">
        </div>
        <div class="row">
          <label>距離 L(m)</label><input id="distance" type="number" value="2.0" step="0.1">
          <label>往復倍率</label>
          <select id="mult">
            <option value="1">×1</option>
            <option value="2" selected>×2</option>
            <option value="4">×4</option>
          </select>
        </div>
        <div class="row">
          <button id="btnCalc" class="btn-primary">速度 v = 距離/Δt</button>
        </div>
        <div class="row">
          <input id="speed" type="text" readonly value="— m/s">
        </div>
      </div>

      <div class="card">
        <h3>🎙 入力デバイス</h3>
        <div class="row">
          <select id="selDevice"></select><button id="btnRefresh">⟳</button>
        </div>
      </div>

      <div class="card">
        <h3>📝 ログ</h3>
        <div id="log"></div>
      </div>

    </div>

    <div id="main">
      <header>
        <div class="title">
          Oscillo Lab.
          <img src="pllab.png" alt="Physics Exam Lab Logo">
        </div>
        <div class="right">SR: <span id="sr">—</span> Hz · FFT: <span id="fftSz">—</span></div>
      </header>
      <canvas id="scope"></canvas>
    </div>
  </div>
  <footer>Design by ODA Tomohiro</footer>

<script>
(()=>{
  const els = {
    canvas: document.getElementById('scope'),
    sr: document.getElementById('sr'),
    fftSz: document.getElementById('fftSz'),
    log: document.getElementById('log'),
    // view & scale
    btnWave: document.getElementById('btnWave'),
    btnFFT: document.getElementById('btnFFT'),
    btnFull: document.getElementById('btnFull'),
    chkAxes: document.getElementById('chkAxes'),
    chkAutoNorm: document.getElementById('chkAutoNorm'),
    chkShowRec: document.getElementById('chkShowRec'),
    rangeGain: document.getElementById('rangeGain'),
    rangeTime: document.getElementById('rangeTime'),
    displayMax: document.getElementById('displayMax'),
    displayMaxLabel: document.getElementById('displayMaxLabel'),
    cycleMode: document.getElementById('cycleMode'),
    cycleCount: document.getElementById('cycleCount'),
    // trigger
    chkTrigger: document.getElementById('chkTrigger'),
    triggerLevel: document.getElementById('triggerLevel'),
    triggerLabel: document.getElementById('triggerLabel'),
    avgCycles: document.getElementById('avgCycles'),
    avgLabel: document.getElementById('avgLabel'),
    // record
    btnRec: document.getElementById('btnRec'),
    btnSave: document.getElementById('btnSave'),
    // impulse single
    btnPulse: document.getElementById('btnPulse'),
    btnNoise: document.getElementById('btnNoise'),
    impMs: document.getElementById('impMs'),
    impGain: document.getElementById('impGain'),
    // combo record+play
    btnCombo: document.getElementById('btnCombo'),
    comboType: document.getElementById('comboType'),
    comboDurMs: document.getElementById('comboDurMs'),
    comboPreMs: document.getElementById('comboPreMs'),
    comboPostMs: document.getElementById('comboPostMs'),
    comboGain: document.getElementById('comboGain'),
    comboOscPanel: document.getElementById('comboOscPanel'),
    comboOscWave: document.getElementById('comboOscWave'),
    comboOscFreqSlider: document.getElementById('comboOscFreqSlider'),
    comboOscFreqInput: document.getElementById('comboOscFreqInput'),
    // markers
    markA: document.getElementById('markA'),
    markB: document.getElementById('markB'),
    deltaT: document.getElementById('deltaT'),
    distance: document.getElementById('distance'),
    mult: document.getElementById('mult'),
    btnCalc: document.getElementById('btnCalc'),
    speed: document.getElementById('speed'),
    // device
    selDevice: document.getElementById('selDevice'),
    btnRefresh: document.getElementById('btnRefresh'),
    // oscillator (standalone)
    stereoMode: document.getElementById('stereoMode'),
    oscWave: document.getElementById('oscWave'),
    oscFreqSlider: document.getElementById('oscFreqSlider'),
    oscFreqInput: document.getElementById('oscFreqInput'),
    oscGain: document.getElementById('oscGain'),
    btnOscStart: document.getElementById('btnOscStart'),
    btnOscStop: document.getElementById('btnOscStop'),
    // stereo
    monoControls: document.getElementById('monoControls'),
    stereoControls: document.getElementById('stereoControls'),
    oscWaveL: document.getElementById('oscWaveL'),
    oscWaveR: document.getElementById('oscWaveR'),
    oscFreqL: document.getElementById('oscFreqL'),
    oscFreqR: document.getElementById('oscFreqR'),
    oscFreqInputL: document.getElementById('oscFreqInputL'),
    oscFreqInputR: document.getElementById('oscFreqInputR'),
    enableL: document.getElementById('enableL'),
    enableR: document.getElementById('enableR'),
    beatHz: document.getElementById('beatHz'),
  };

  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

  const state = {
    ctx: null,
    analyser: null,
    srcNode: null,
    gainNode: null,
    mediaStream: null,
    deviceId: null,
    view: 'time',
    timeSpanSec: parseFloat(els.rangeTime ? els.rangeTime.value : 0.25),
    gain: 1,
    displayMax: parseFloat(els.displayMax ? els.displayMax.value : 1.0),
    fftSize: 2048,
    dataTime: null,
    dataFreq: null,
    w: 0, h: 0,
    markerA: null, markerB: null,
    recorder: null, recording: false, chunks: [], lastBlob: null,
    recVisSamples: new Float32Array(0), recSR: 48000,
    tZoom: [0,1],
    dragging: false, dragStartX: 0, dragEndX: 0, dragMoved: false,
    oscNode: null, oscGainNode: null,
    oscNodeL: null, oscNodeR: null, gainL: null, gainR: null, panL: null, panR: null,
    cursorX: null
  };

  function log(m){ const d=document.createElement('div'); d.textContent='• '+m; els.log.prepend(d); }

  // Canvas sizing
  function fitCanvas(){
    state.w = Math.floor(els.canvas.clientWidth * DPR);
    state.h = Math.floor((window.innerHeight - 48 - 34) * DPR);
    els.canvas.width = state.w; els.canvas.height = state.h;
    els.canvas.style.width = '100%'; els.canvas.style.height = (state.h/DPR)+'px';
  }
  new ResizeObserver(fitCanvas).observe(document.getElementById('main'));
  fitCanvas();

  // Devices
  async function listDevices(){
    try{
      const list = await navigator.mediaDevices.enumerateDevices();
      const audIns = list.filter(d=>d.kind==='audioinput');
      els.selDevice.innerHTML = '';
      audIns.forEach((d,i)=>{
        const opt=document.createElement('option');
        opt.value=d.deviceId; opt.textContent=d.label||`マイク ${i+1}`;
        els.selDevice.appendChild(opt);
      });
      if(audIns.length){ if(!state.deviceId) state.deviceId = audIns[0].deviceId; els.selDevice.value=state.deviceId; }
    }catch(e){ log('デバイス列挙に失敗: '+e.message); }
  }

  async function startMic(){
    try{
      if(state.mediaStream) stopMic();
      const constraints = { audio: { deviceId: state.deviceId ? {exact: state.deviceId} : undefined, echoCancellation:false, noiseSuppression:false, autoGainControl:false } };
      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      state.mediaStream = stream;
      if(!state.ctx) state.ctx = new (window.AudioContext || window.webkitAudioContext)();
      const ctx = state.ctx;
      state.recSR = ctx.sampleRate;

      state.srcNode = ctx.createMediaStreamSource(stream);
      state.gainNode = ctx.createGain(); state.gainNode.gain.value = state.gain;
      state.analyser = ctx.createAnalyser(); state.analyser.fftSize = state.fftSize; state.analyser.smoothingTimeConstant = 0.12;
      state.srcNode.connect(state.gainNode); state.gainNode.connect(state.analyser);

      state.dataTime = new Float32Array(state.analyser.fftSize);
      state.dataFreq = new Uint8Array(state.analyser.frequencyBinCount);

      els.sr.textContent = ctx.sampleRate.toFixed(0);
      els.fftSz.textContent = state.analyser.fftSize + ' / ' + (state.analyser.frequencyBinCount*2);
      log('マイク開始');
    }catch(e){ log('マイク開始失敗: '+e.message); }
  }
  function stopMic(){
    if(state.mediaStream){ state.mediaStream.getTracks().forEach(t=>t.stop()); state.mediaStream=null; }
    if(state.srcNode){ try{ state.srcNode.disconnect(); }catch{} state.srcNode=null; }
    if(state.gainNode){ try{ state.gainNode.disconnect(); }catch{} state.gainNode=null; }
    if(state.analyser){ state.analyser=null; }
    log('マイク停止');
  }

  // Recorder
  function startRec(){
    if(!state.mediaStream){ log('⚠ マイク未接続'); return; }
    try{
      state.recorder = new MediaRecorder(state.mediaStream);
    }catch(e){ log('Recorder作成失敗: '+e.message); return; }
    state.chunks = [];
    state.recVisSamples = new Float32Array(0);
    state.recorder.ondataavailable = e=>{ if(e.data && e.data.size>0) state.chunks.push(e.data); };
    state.recorder.onstop = ()=>{
      state.lastBlob = new Blob(state.chunks, {type: state.recorder.mimeType || 'audio/webm'});
      els.btnSave.disabled = !state.lastBlob;
      log('録音完了: '+Math.round((state.lastBlob?.size||0)/1024)+' KB');
    };
    state.recorder.start();
    state.recording = true; els.btnRec.textContent = '⏺ Stop';
    log('録音開始');
  }
  function stopRec(){
    if(state.recorder && state.recording){ state.recorder.stop(); }
    state.recording = false; els.btnRec.textContent = '⏺ Start';
    log('録音停止');
  }
  function saveAudio(){
    if(!state.lastBlob){ return; }
    const ext = (state.recorder && state.recorder.mimeType && state.recorder.mimeType.includes('webm')) ? 'webm' : 'ogg';
    const url = URL.createObjectURL(state.lastBlob);
    const a=document.createElement('a'); a.href=url; a.download=`oscillo-recording-${Date.now()}.${ext}`; a.click();
    setTimeout(()=>URL.revokeObjectURL(url),1500);
  }

  // Simple impulse/noise
  function playStimulus(kind, durMs, gain=0.9){
    if(!state.ctx) state.ctx = new (window.AudioContext||window.webkitAudioContext)();
    const ctx = state.ctx;
    const frames = Math.max(1, Math.round(ctx.sampleRate * (durMs/1000)));
    const buffer = ctx.createBuffer(1, frames, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    if(kind==='pulse') data[0]=1.0; else for(let i=0;i<frames;i++) data[i]=(Math.random()*2-1)*0.5;
    const src = ctx.createBufferSource(); src.buffer = buffer;
    const g = ctx.createGain(); g.gain.value = gain;
    src.connect(g).connect(ctx.destination);
    src.start();
    setTimeout(()=>{ try{src.stop();}catch{} }, durMs+5);
  }

  // Oscillator (standalone)
  function oscStart(){
    if(!state.ctx) state.ctx=new (window.AudioContext||window.webkitAudioContext)();
    oscStop();
    const ctx=state.ctx;
    const gainValue=parseFloat(els.oscGain.value)||0.5;

    if(els.stereoMode.checked){
      const useL = !!els.enableL.checked;
      const useR = !!els.enableR.checked;

      if(useL){
        const oscL=ctx.createOscillator(); oscL.type=els.oscWaveL.value;
        const sliderFL=parseFloat(els.oscFreqL.value)||440;
        const inputFL=parseFloat(els.oscFreqInputL.value)||sliderFL;
        const fL=(inputFL>600)? inputFL : sliderFL;
        const gL=ctx.createGain(); gL.gain.value=gainValue;
        const pL=ctx.createStereoPanner(); pL.pan.value=-1;
        oscL.frequency.value=fL; oscL.connect(gL).connect(pL).connect(ctx.destination); oscL.start();
        state.oscNodeL=oscL; state.gainL=gL; state.panL=pL;
      }
      if(useR){
        const oscR=ctx.createOscillator(); oscR.type=els.oscWaveR.value;
        const sliderFR=parseFloat(els.oscFreqR.value)||440;
        const inputFR=parseFloat(els.oscFreqInputR.value)||sliderFR;
        const fR=(inputFR>600)? inputFR : sliderFR;
        const gR=ctx.createGain(); gR.gain.value=gainValue;
        const pR=ctx.createStereoPanner(); pR.pan.value=1;
        oscR.frequency.value=fR; oscR.connect(gR).connect(pR).connect(ctx.destination); oscR.start();
        state.oscNodeR=oscR; state.gainR=gR; state.panR=pR;
      }
      updateBeat();
      log(`ステレオ発振: L=${useL?'ON':'OFF'}, R=${useR?'ON':'OFF'}`);
    }else{
      const osc=ctx.createOscillator(); osc.type=els.oscWave.value;
      const sliderF=parseFloat(els.oscFreqSlider.value)||440;
      const inputF=parseFloat(els.oscFreqInput.value)||sliderF;
      const f=(inputF>600)? inputF : sliderF;
      const g=ctx.createGain(); g.gain.value=gainValue;
      osc.frequency.value=f; osc.connect(g).connect(ctx.destination); osc.start();
      state.oscNode=osc; state.oscGainNode=g;
      log(`モノラル発振: ${f}Hz (${osc.type})`);
    }
  }
  function oscStop(){
    if(state.oscNode){ try{state.oscNode.stop();}catch{} state.oscNode.disconnect(); state.oscNode=null; }
    if(state.oscGainNode){ state.oscGainNode.disconnect(); state.oscGainNode=null; }
    if(state.oscNodeL){ try{state.oscNodeL.stop();}catch{} state.oscNodeL.disconnect(); state.oscNodeL=null; }
    if(state.oscNodeR){ try{state.oscNodeR.stop();}catch{} state.oscNodeR.disconnect(); state.oscNodeR=null; }
    if(state.gainL){ state.gainL.disconnect(); state.gainL=null; } if(state.gainR){ state.gainR.disconnect(); state.gainR=null; }
    if(state.panL){ state.panL.disconnect(); state.panL=null; } if(state.panR){ state.panR.disconnect(); state.panR=null; }
    log('オシレーター停止');
  }

  // Beat display
  function getStereoFreqs(){
    const sliderFL=parseFloat(els.oscFreqL.value)||440;
    const inputFL=parseFloat(els.oscFreqInputL.value)||sliderFL;
    const fL=(inputFL>600)? inputFL : sliderFL;
    const sliderFR=parseFloat(els.oscFreqR.value)||440;
    const inputFR=parseFloat(els.oscFreqInputR.value)||sliderFR;
    const fR=(inputFR>600)? inputFR : sliderFR;
    return {fL, fR};
  }
  function updateBeat(){
    if(!els.stereoMode.checked){ if(els.beatHz) els.beatHz.textContent='—'; return; }
    if(!els.enableL.checked || !els.enableR.checked){ els.beatHz.textContent='—'; return; }
    const {fL, fR} = getStereoFreqs();
    const beat = Math.abs(fL - fR);
    els.beatHz.textContent = isFinite(beat) ? beat.toFixed(2) : '—';
  }

  // Combined: record -> play (pulse/noise/osc) -> stop
  async function comboRecordPlay(){
    if(!state.mediaStream) await startMic();
    if(!state.mediaStream){ log('⚠ マイク未接続'); return; }
    const type = els.comboType.value;
    const dur = parseInt(els.comboDurMs.value||'200',10);
    const pre = parseInt(els.comboPreMs.value||'200',10);
    const post = parseInt(els.comboPostMs.value||'500',10);
    const gain = parseFloat(els.comboGain.value||'0.9');

    startRec();
    setTimeout(()=>{
      if(type==='pulse' || type==='noise'){
        playStimulus(type, dur, gain); log(`発音(${type}, ${dur}ms, gain=${gain})`);
      }else if(type==='osc'){
        if(!state.ctx) state.ctx=new (window.AudioContext||window.webkitAudioContext)();
        const ctx=state.ctx;
        const osc=ctx.createOscillator();
        osc.type=els.comboOscWave.value;
        const sliderF=parseFloat(els.comboOscFreqSlider.value)||440;
        const inputF = parseFloat(els.comboOscFreqInput.value)||sliderF;
        const f=(inputF>600)? inputF : sliderF;
        const g=ctx.createGain(); g.gain.value=gain;
        osc.connect(g).connect(ctx.destination);
        osc.frequency.value=f; osc.start();
        log(`発音(osc: ${osc.type}, ${f}Hz, gain=${gain})`);
        setTimeout(()=>{ try{osc.stop();}catch{} }, dur);
      }
    }, pre);
    setTimeout(()=>{ stopRec(); }, pre + dur + post);
  }

  function appendRecVis(samples){
    const old = state.recVisSamples;
    const merged = new Float32Array(old.length + samples.length);
    merged.set(old, 0); merged.set(samples, old.length);
    state.recVisSamples = merged;
  }

  // FFT helpers
  function nextPow2(n){ let p=1; while(p<n) p<<=1; return p; }
  function fftMag(input, sampleRate){
    const N = nextPow2(input.length);
    const re = new Float32Array(N);
    const im = new Float32Array(N);
    re.set(input);
    let j=0;
    for(let i=1;i<N;i++){
      let bit=N>>1;
      for(; j & bit; bit>>=1){ j ^= bit; }
      j ^= bit;
      if(i<j){ const tr=re[i]; re[i]=re[j]; re[j]=tr; const ti=im[i]; im[i]=re[i]; re[i]=tr; } // corrected below
    }
    // Correct bit-swap (fix the above accidental swap)
    // Recreate arrays properly
    for(let i=0;i<N;i++){ im[i]=0; } // zero imag since we re-messed above
    // Bit-reversal properly:
    j=0
    for(let i=1;i<N;i++){
      let bit=N>>1
      for(; j & bit; bit>>=1){ j^=bit }
      j^=bit
      if(i<j){
        const tr=re[i]; re[i]=re[j]; re[j]=tr;
        const ti=im[i]; im[i]=im[j]; im[j]=ti;
      }
    }
    for(let len=2; len<=N; len<<=1){
      const ang = -2*Math.PI/len;
      const wlenRe = Math.cos(ang), wlenIm = Math.sin(ang);
      for(let i=0;i<N;i+=len){
        let wRe=1, wIm=0;
        for(let k=0;k<(len>>1);k++){
          const uRe=re[i+k], uIm=im[i+k];
          const vRe=re[i+k+(len>>1)]*wRe - im[i+k+(len>>1)]*wIm;
          const vIm=re[i+k+(len>>1)]*wIm + im[i+k+(len>>1)]*wRe;
          re[i+k] = uRe + vRe; im[i+k] = uIm + vIm;
          re[i+k+(len>>1)] = uRe - vRe; im[i+k+(len>>1)] = uIm - vIm;
          const nwRe = wRe*wlenRe - wIm*wlenIm;
          const nwIm = wRe*wlenIm + wIm*wlenRe;
          wRe = nwRe; wIm = nwIm;
        }
      }
    }
    const mags = new Float32Array(N/2);
    for(let i=0;i<N/2;i++){ mags[i] = Math.sqrt(re[i]*re[i] + im[i]*im[i]) / (N/2); }
    let peak=0, idx=0;
    for(let i=1;i<mags.length;i++){ if(mags[i]>peak){ peak=mags[i]; idx=i; } }
    const freq = (idx * sampleRate) / N;
    return {mags, freq};
  }

  // Trigger utility
  function rotateAtTrigger(arr, level){
    const N = arr.length;
    for(let i=0;i<N-1;i++){
      const a = arr[i], b = arr[i+1];
      if(a < level && b >= level){
        const out = new Float32Array(N);
        let k=0;
        for(let j=i; j<N; j++,k++) out[k]=arr[j];
        for(let j=0; j<i; j++,k++) out[k]=arr[j];
        return out;
      }
    }
    return arr;
  }

  // Average cycles
  function averageCycles(arr, sampleRate, cycles){
    if(cycles<=1) return arr;
    const {freq} = fftMag(arr, sampleRate);
    if(!isFinite(freq) || freq<=0) return arr;
    const period = Math.max(8, Math.round(sampleRate / freq));
    const total = Math.min(arr.length, period * cycles);
    const buf = arr.subarray(0, total);
    const out = new Float32Array(period);
    let count = Math.floor(total / period);
    if(count<1) return arr;
    for(let c=0;c<count;c++){ for(let i=0;i<period;i++){ out[i] += buf[c*period + i]; } }
    for(let i=0;i<period;i++) out[i] /= count;
    return out;
  }

  // Drawing helpers
  function drawGrid(ctx){
    const w=state.w, h=state.h;
    const g=ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0,'#0b1018'); g.addColorStop(1,'#0a0f14');
    ctx.fillStyle=g; ctx.fillRect(0,0,w,h);
    ctx.strokeStyle='rgba(255,255,255,0.05)'; ctx.lineWidth=1;
    ctx.beginPath();
    const gx=10, gy=8;
    for(let i=1;i<gx;i++){ const x=(w*i/gx)|0; ctx.moveTo(x,0); ctx.lineTo(x,h); }
    for(let j=1;j<gy;j++){ const y=(h*j/gy)|0; ctx.moveTo(0,y); ctx.lineTo(0,y); ctx.moveTo(0,y); ctx.lineTo(w,y); }
    ctx.stroke();
  }
  function drawAxes(ctx, opt){
    if(!els.chkAxes.checked) return;
    const w=state.w, h=state.h;
    ctx.fillStyle='#ffffff'; ctx.font=`${10*DPR}px system-ui`; ctx.textAlign='left'; ctx.textBaseline='top';
    if(opt.mode==='time'){
      const ticks=6;
      const spanSec = opt.spanSec;
      for(let i=0;i<=ticks;i++){
        const t=i/ticks * spanSec;
        const x=Math.round(i/ticks*w);
        ctx.fillRect(x, h-6*DPR, 1*DPR, 6*DPR);
        ctx.fillText(Math.round(t*1000)+'ms', Math.min(x+2*DPR, w-52*DPR), h-14*DPR);
      }
      const ya=[-1,-0.5,0,0.5,1];
      ya.forEach(v=>{ const y=Math.round((1-(v+1)/2)*h); ctx.fillRect(0,y,6*DPR,1*DPR); ctx.fillText(String(v),6*DPR+2*DPR,Math.max(0,y-8*DPR)); });
    }else{
      const ny = opt.nyquist;
      const ticks=6;
      for(let i=0;i<=ticks;i++){
        const f=Math.round(i/ticks * ny);
        const x=Math.round(i/ticks*w);
        ctx.fillRect(x, h-6*DPR, 1*DPR, 6*DPR);
        ctx.fillText(f+'Hz', Math.min(x+2*DPR, w-52*DPR), h-14*DPR);
      }
      const ya=[0,-20,-40,-60,-80];
      ya.forEach((db,idx)=>{ const y=Math.round((idx/(ya.length-1))*h); ctx.fillRect(0,y,6*DPR,1*DPR); ctx.fillText(db+'dB',6*DPR+2*DPR,Math.max(0,y-8*DPR)); });
    }
  }
  function drawMarkers(ctx, spanSec){
    if(state.view!=='time') return;
    const w=state.w, h=state.h;
    const drawLine = (t, color)=>{
      if(t==null) return;
      const x = Math.max(0, Math.min(w-1, t/spanSec * w));
      ctx.save();
      ctx.strokeStyle=color; ctx.fillStyle=color; ctx.lineWidth=1*DPR;
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();
      ctx.fillRect(x-3*DPR, 8*DPR, 6*DPR, 6*DPR);
      ctx.restore();
    };
    drawLine(state.markerA, '#80ffea');
    drawLine(state.markerB, '#a8e6ff');

    if(state.markerA!=null || state.markerB!=null){
      const aText = (state.markerA!=null) ? `A: ${state.markerA.toFixed(4)}s` : 'A: —';
      const bText = (state.markerB!=null) ? `B: ${state.markerB.toFixed(4)}s` : 'B: —';
      const dt = (state.markerA!=null && state.markerB!=null) ? Math.abs(state.markerB-state.markerA) : null;
      const dText = (dt!=null) ? `Δt: ${dt.toFixed(6)}s` : 'Δt: —';
      ctx.save();
      ctx.font = `${12*DPR}px system-ui, sans-serif`;
      ctx.textAlign='left'; ctx.textBaseline='top';
      ctx.fillStyle='rgba(255,255,255,0.9)';
      const x0 = 8*DPR, y0 = 6*DPR, lh = 16*DPR;
      ctx.fillText(aText, x0, y0);
      ctx.fillText(bText, x0, y0 + lh);
      ctx.fillText(dText, x0, y0 + lh*2);
      ctx.restore();
    }
  }
  function drawDragSelection(ctx){
    if(!state.dragging) return;
    const x1=Math.min(state.dragStartX,state.dragEndX);
    const x2=Math.max(state.dragStartX,state.dragEndX);
    ctx.save();
    ctx.fillStyle='rgba(129,236,236,0.15)';
    ctx.fillRect(x1,0,x2-x1,state.h);
    ctx.strokeStyle='rgba(129,236,236,0.9)'; ctx.lineWidth=2;
    ctx.strokeRect(x1+0.5,0.5,x2-x1-1,state.h-1);
    ctx.restore();
  }

  function estimateFreqFromSegment(seg, sr){
    if(!seg || seg.length<32) return null;
    const {freq} = fftMag(seg, sr);
    return (isFinite(freq) && freq>0) ? freq : null;
  }

  function renderOnce(){
    const ctx = els.canvas.getContext('2d');
    drawGrid(ctx);
    if(els.chkShowRec.checked){
      if(state.view==='time') drawRecordedTime(ctx); else drawRecordedFFT(ctx);
      drawDragSelection(ctx);
    }else{
      if(!state.analyser) return;
      if(state.view==='time') drawRealtimeTime(ctx); else drawRealtimeFFT(ctx);
      if(state.recording){
        state.analyser.getFloatTimeDomainData(state.dataTime);
        appendRecVis(state.dataTime);
      }
    }
  }
  function loop(){ renderOnce(); requestAnimationFrame(loop); }

  function scaleSegment(seg, sampleRate){
    let a = seg;
    if(els.chkAutoNorm.checked){
      let max=0; for(let i=0;i<a.length;i++){ const m=Math.abs(a[i]); if(m>max) max=m; }
      if(max>1e-6){ const s=1/max; const t=new Float32Array(a.length); for(let i=0;i<a.length;i++) t[i]=a[i]*s; a=t; }
    }else{
      const dmax = state.displayMax>1e-6 ? state.displayMax : 1.0;
      const t=new Float32Array(a.length); for(let i=0;i<a.length;i++) t[i]=a[i]/dmax; a=t;
    }
    if(els.chkTrigger.checked){
      const lvl = parseFloat(els.triggerLevel.value)||0;
      a = rotateAtTrigger(a, lvl);
      const cycles = parseInt(els.avgCycles.value||'1',10);
      if(cycles>1){ a = averageCycles(a, sampleRate, cycles); }
    }
    return a;
  }

  function drawTimeFromArray(ctx, arr, sampleRate, spanSec){
    const w=state.w, h=state.h;
    const a = arr;
    const mid=h/2; const scaleY=h*0.42*state.gain;
    ctx.beginPath();
    for(let i=0;i<a.length;i++){
      const x=i/a.length*w;
      const y=mid + Math.max(-1,Math.min(1,a[i]))*scaleY;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.strokeStyle='#ffffff'; ctx.lineWidth=Math.max(1,2*DPR); ctx.stroke();
    const shownSec = spanSec || (a.length/sampleRate);
    drawAxes(ctx,{mode:'time', spanSec: shownSec});
    drawMarkers(ctx, shownSec);
  }

  function drawRealtimeTime(ctx){
    state.analyser.getFloatTimeDomainData(state.dataTime);
    let seg = state.dataTime;
    let spanSecDesired = state.timeSpanSec;
    if(els.cycleMode.checked){
      const est = estimateFreqFromSegment(seg, state.ctx.sampleRate);
      const Ncyc = Math.max(1, parseInt(els.cycleCount.value||'5', 10));
      if(est && est>0){ spanSecDesired = Ncyc / est; }
    }
    const need = Math.max(16, Math.floor(spanSecDesired * state.ctx.sampleRate));
    if(need < seg.length){ seg = seg.subarray(seg.length-need); }
    seg = scaleSegment(seg, state.ctx.sampleRate);
    drawTimeFromArray(ctx, seg, state.ctx.sampleRate, seg.length/state.ctx.sampleRate);
  }

  function drawRealtimeFFT(ctx){
    state.analyser.getByteFrequencyData(state.dataFreq);
    const w=state.w, h=state.h;
    const bins=state.dataFreq.length;
    const barW=Math.max(1, (w/bins));
    let maxV = 1;
    for(let i=0;i<bins;i++){ if(state.dataFreq[i]>maxV) maxV=state.dataFreq[i]; }
    for(let i=0;i<bins;i++){
      const mag=state.dataFreq[i]/maxV;
      const barH=mag*(h*0.9);
      const x=i*barW; const y=h-barH;
      const hue=180+120*mag;
      ctx.fillStyle=`hsl(${hue} 80% 55% / 0.95)`;
      ctx.fillRect(x,y,barW-0.5,barH);
    }
    drawAxes(ctx,{mode:'freq', nyquist: (state.ctx? state.ctx.sampleRate/2 : 22050)});
    drawFFTCursorOverlay(ctx, state.ctx.sampleRate, bins, (i)=> state.dataFreq[i]/maxV );
  }

  function drawRecordedTime(ctx){
    const full = state.recVisSamples;
    if(!full || full.length===0){ return drawNoData(ctx); }
    const [a,b]=state.tZoom; const ia=Math.floor(a*full.length), ib=Math.max(ia+1, Math.floor(b*full.length));
    let seg = full.subarray(ia, ib);
    if(els.cycleMode.checked){
      const est = estimateFreqFromSegment(seg, state.recSR);
      const Ncyc = Math.max(1, parseInt(els.cycleCount.value||'5',10));
      if(est && est>0){
        const span = Math.max(16, Math.floor((Ncyc/est) * state.recSR));
        if(span < seg.length) seg = seg.subarray(seg.length-span);
      }
    }
    seg = scaleSegment(seg, state.recSR);
    drawTimeFromArray(ctx, seg, state.recSR, seg.length/state.recSR);
  }
  function drawRecordedFFT(ctx){
    const full = state.recVisSamples;
    if(!full || full.length===0){ return drawNoData(ctx); }
    const [a,b]=state.tZoom;
    const ia=Math.floor(a*full.length), ib=Math.max(ia+1, Math.floor(b*full.length));
    const segment = full.subarray(ia, ib);
    const N = segment.length; const win = new Float32Array(N);
    for(let i=0;i<N;i++){ const wH=0.5 - 0.5*Math.cos(2*Math.PI*i/(N-1)); win[i]=segment[i]*wH; }
    const {mags} = fftMag(win, state.recSR);
    const bins=mags.length;
    let maxMag=1e-9; for(let i=0;i<bins;i++){ if(mags[i]>maxMag) maxMag=mags[i]; }
    const w=state.w, h=state.h;
    const barW=Math.max(1,(w/bins));
    for(let i=0;i<bins;i++){
      const mag=mags[i]/maxMag;
      const barH=mag*(h*0.9);
      const x=i*barW; const y=h-barH;
      const hue=180+120*mag;
      const ctx=els.canvas.getContext('2d');
      ctx.fillStyle=`hsl(${hue} 80% 55% / 0.95)`;
      ctx.fillRect(x,y,barW-0.5,barH);
    }
    const nyquist = state.recSR/2;
    const ctx2 = els.canvas.getContext('2d');
    drawAxes(ctx2,{mode:'freq', nyquist});
    drawFFTCursorOverlay(ctx2, state.recSR, bins, (i)=> mags[i]/maxMag );
  }

  function drawNoData(ctx){
    ctx.fillStyle='rgba(255,255,255,0.65)';
    ctx.font=`${14*DPR}px system-ui`;
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText('録音結果がありません', state.w/2, state.h/2);
  }

  function drawFFTCursorOverlay(ctx, sampleRate, bins, getMag){
    const w=state.w, h=state.h;
    const x = state.cursorX==null ? null : Math.max(0, Math.min(w-1, state.cursorX));
    if(x==null) return;
    const bin = Math.max(0, Math.min(bins-1, Math.round((x/w) * (bins-1))));
    const nyq = sampleRate/2;
    const freq = (bin / (bins-1)) * nyq;
    const mag = getMag(bin);
    const db = 20*Math.log10(Math.max(1e-9, mag));
    ctx.save();
    ctx.strokeStyle='rgba(255,255,255,0.75)'; ctx.lineWidth=1;
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();
    const text = `${freq.toFixed(1)} Hz  |  ${db.toFixed(1)} dB`;
    const pad=6; ctx.font=`${12*DPR}px system-ui`; const tw=ctx.measureText(text).width+pad*2;
    const th=18*DPR;
    let bx = Math.min(Math.max(4*DPR, x - tw/2), w - tw - 4*DPR);
    let by = 6*DPR;
    ctx.fillStyle='rgba(0,0,0,0.7)'; ctx.fillRect(bx, by, tw, th);
    ctx.strokeStyle='rgba(255,255,255,0.5)'; ctx.strokeRect(bx+0.5, by+0.5, tw-1, th-1);
    ctx.fillStyle='#fff'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(text, bx+tw/2, by+th/2+1);
    ctx.restore();
  }

  // ====== 操作（左クリック＝マーカー／右ドラッグ＝ズーム） ======
  const DPR2 = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  els.canvas.addEventListener('mousedown', (ev)=>{
    if(ev.button===0){
      const isTimeView = (state.view==='time');
      if(!isTimeView) return;
      const rect = els.canvas.getBoundingClientRect();
      const x = (ev.clientX - rect.left) * DPR2;
      let tSec;
      if(els.chkShowRec.checked){
        const [a,b]=state.tZoom;
        const totalSec = state.recVisSamples.length / state.recSR;
        const startSec = totalSec * a;
        const spanSec = totalSec * (b-a);
        tSec = startSec + (x/state.w) * spanSec;
      }else{
        tSec = (x / state.w) * state.timeSpanSec;
      }
      placeMarker(tSec);
    }
    if(ev.button===2){
      if(!els.chkShowRec.checked) return;
      state.dragging=true; state.dragMoved=false;
      const rect=els.canvas.getBoundingClientRect();
      state.dragStartX = (ev.clientX - rect.left) * DPR2;
      state.dragEndX = state.dragStartX;
    }
  });
  els.canvas.addEventListener('mousemove', (ev)=>{
    const rect = els.canvas.getBoundingClientRect();
    state.cursorX = (ev.clientX - rect.left) * DPR2;
    if(!state.dragging) return;
    state.dragEndX = state.cursorX;
    if(Math.abs(state.dragEndX - state.dragStartX) > 3) state.dragMoved = true;
  });
  els.canvas.addEventListener('mouseleave', ()=>{ state.cursorX=null; });
  function applyZoomFromDrag(){
    const x1=Math.min(state.dragStartX,state.dragEndX);
    const x2=Math.max(state.dragStartX,state.dragEndX);
    const minSel = 6*DPR2;
    if(x2-x1 < minSel){ state.dragging=false; return false; }
    const a = x1/state.w, b = x2/state.w;
    state.tZoom=[
      state.tZoom[0] + a*(state.tZoom[1]-state.tZoom[0]),
      state.tZoom[0] + b*(state.tZoom[1]-state.tZoom[0])
    ];
    state.dragging=false;
    return true;
  }
  els.canvas.addEventListener('mouseup', (ev)=>{
    if(ev.button!==2) return;
    if(!els.chkShowRec.checked) return;
    const moved = state.dragMoved;
    if(state.dragging){ applyZoomFromDrag(); }
    state.dragging=false; state.dragMoved=false;
    if(!moved){ state.tZoom=[0,1]; }
  });
  els.canvas.addEventListener('contextmenu', (e)=>e.preventDefault());
  els.canvas.addEventListener('dblclick', ()=>{
    if(els.chkShowRec.checked){ state.tZoom=[0,1]; }
    if(state.view==='time'){
      state.markerA=state.markerB=null; els.markA.value=els.markB.value='—'; els.deltaT.value='—'; els.speed.value='— m/s';
    }
  });

  function placeMarker(tSec){
    if(state.markerA==null){ state.markerA=tSec; els.markA.value=tSec.toFixed(4); }
    else if(state.markerB==null){ state.markerB=tSec; els.markB.value=tSec.toFixed(4); }
    else{
      const dA=Math.abs(tSec-state.markerA), dB=Math.abs(tSec-state.markerB);
      if(dA<dB){ state.markerA=tSec; els.markA.value=tSec.toFixed(4); }
      else{ state.markerB=tSec; els.markB.value=tSec.toFixed(4); }
    }
    const dt=(state.markerA!=null && state.markerB!=null) ? Math.abs(state.markerB-state.markerA) : null;
    els.deltaT.value = dt!=null ? dt.toFixed(6) : '—';
  }

  // Bindings
  document.getElementById('btnWave').addEventListener('click', ()=>{ state.view='time'; btnSel('btnWave','btnFFT'); });
  document.getElementById('btnFFT').addEventListener('click',  ()=>{ state.view='fft';  btnSel('btnFFT','btnWave'); });
  function btnSel(on,off){ document.getElementById(on).classList.add('btn-primary'); document.getElementById(off).classList.remove('btn-primary'); }
  document.getElementById('btnFull').addEventListener('click', ()=>{ const el=document.documentElement; !document.fullscreenElement ? el.requestFullscreen?.() : document.exitFullscreen?.(); });
  document.getElementById('rangeGain').addEventListener('input', e=>{ const v=parseFloat(e.target.value); if(!isFinite(v))return; if(state.gainNode) state.gainNode.gain.value=v; state.gain=v; });
  document.getElementById('rangeTime').addEventListener('input', e=>{ const v=parseFloat(e.target.value); if(!isFinite(v))return; state.timeSpanSec=v; });
  document.getElementById('displayMax').addEventListener('input', e=>{
    state.displayMax = parseFloat(e.target.value)||1.0;
    els.displayMaxLabel.textContent = state.displayMax.toFixed(2);
  });
  document.getElementById('triggerLevel').addEventListener('input', e=>{
    els.triggerLabel.textContent = parseFloat(e.target.value).toFixed(2);
  });
  document.getElementById('avgCycles').addEventListener('input', e=>{
    els.avgLabel.textContent = `${e.target.value} 周期`;
  });
  document.getElementById('btnRec').addEventListener('click', ()=>{ state.recording? stopRec() : startRec(); });
  document.getElementById('btnSave').addEventListener('click', saveAudio);
  document.getElementById('btnPulse').addEventListener('click', ()=> playStimulus('pulse', parseInt(els.impMs.value||'20',10), parseFloat(els.impGain.value||'0.9')) );
  document.getElementById('btnNoise').addEventListener('click', ()=> playStimulus('noise', parseInt(els.impMs.value||'20',10), parseFloat(els.impGain.value||'0.9')) );
  document.getElementById('btnCombo').addEventListener('click', comboRecordPlay);
  document.getElementById('btnCalc').addEventListener('click', ()=>{
    const dt = parseFloat(els.deltaT.value);
    if(!isFinite(dt) || dt<=0){ els.speed.value='— m/s'; return; }
    const L=parseFloat(els.distance.value||'0'); const m=parseFloat(els.mult.value||'1');
    const v=(L*m)/dt; els.speed.value=v.toFixed(2)+' m/s';
  });
  document.getElementById('selDevice').addEventListener('change', e=>{ state.deviceId=e.target.value; if(state.mediaStream) startMic(); });
  document.getElementById('btnRefresh').addEventListener('click', listDevices);

  // Oscillator (standalone) UI
  els.btnOscStart.addEventListener('click', oscStart);
  els.btnOscStop.addEventListener('click', oscStop);
  els.oscWave.addEventListener('change', ()=>{ if(state.oscNode) state.oscNode.type=els.oscWave.value; });
  // Mono sync
  els.oscFreqSlider.addEventListener('input', e=>{
    els.oscFreqInput.value=e.target.value;
    if(state.oscNode) state.oscNode.frequency.value=parseFloat(e.target.value);
  });
  els.oscFreqInput.addEventListener('input', e=>{
    const val=parseFloat(e.target.value);
    if(val<=600){ els.oscFreqSlider.value=val; }
    if(state.oscNode) state.oscNode.frequency.value=val;
  });
  els.oscGain.addEventListener('input', e=>{
    const v=parseFloat(e.target.value);
    if(state.oscGainNode) state.oscGainNode.gain.value=v;
    if(state.gainL) state.gainL.gain.value=v;
    if(state.gainR) state.gainR.gain.value=v;
  });

  // Stereo toggle & updates
  els.stereoMode.addEventListener('change', ()=>{
    const on = els.stereoMode.checked;
    els.monoControls.classList.toggle('hide', on);
    els.stereoControls.classList.toggle('hide', !on);
    updateBeat();
  });

  // Stereo sync (L/R slider <-> number 双方向同期)
  function syncStereoRuntime(){
    if(state.oscNodeL){
      const sliderFL=parseFloat(els.oscFreqL.value)||440;
      const inputFL=parseFloat(els.oscFreqInputL.value)||sliderFL;
      state.oscNodeL.frequency.value = (inputFL>600)? inputFL : sliderFL;
      state.oscNodeL.type = els.oscWaveL.value;
    }
    if(state.oscNodeR){
      const sliderFR=parseFloat(els.oscFreqR.value)||440;
      const inputFR=parseFloat(els.oscFreqInputR.value)||sliderFR;
      state.oscNodeR.frequency.value = (inputFR>600)? inputFR : sliderFR;
      state.oscNodeR.type = els.oscWaveR.value;
    }
  }
  ['input','change'].forEach(evt=>{
    [els.oscFreqL, els.oscFreqInputL].forEach(el=> el.addEventListener(evt, e=>{
      if(e.target===els.oscFreqL){ els.oscFreqInputL.value = e.target.value; }
      if(e.target===els.oscFreqInputL && parseFloat(e.target.value)<=600){ els.oscFreqL.value = e.target.value; }
      updateBeat(); syncStereoRuntime();
    }));
    [els.oscFreqR, els.oscFreqInputR].forEach(el=> el.addEventListener(evt, e=>{
      if(e.target===els.oscFreqR){ els.oscFreqInputR.value = e.target.value; }
      if(e.target===els.oscFreqInputR && parseFloat(e.target.value)<=600){ els.oscFreqR.value = e.target.value; }
      updateBeat(); syncStereoRuntime();
    }));
    [els.oscWaveL, els.oscWaveR].forEach(el=> el.addEventListener(evt, ()=>{ syncStereoRuntime(); }));
    [els.enableL, els.enableR].forEach(el=> el.addEventListener(evt, ()=>{ updateBeat(); }));
  });

  // Combo oscillator slider/number sync
  els.comboOscFreqSlider.addEventListener('input', e=>{
    els.comboOscFreqInput.value=e.target.value;
  });
  els.comboOscFreqInput.addEventListener('input', e=>{
    const v=parseFloat(e.target.value);
    if(v<=600){ els.comboOscFreqSlider.value=v; }
  });

  // ====== 初期化：ページ表示後すぐにマイク起動 ======
  window.addEventListener('load', () => {
    listDevices().then(startMic).then(()=>{
      // Start render loop after analyser is ready
      loop();
      log('自動マイク起動：ページ表示と同時に波形表示を開始');
    });
  });

})();
</script>
  <!-- === Quick Patch: precise time mapping (no依存), A/B/Δt, single-impulse === -->
<script>
(function(){
  // 要素取得（あなたのHTMLの canvas を使う）
  const cvs = document.querySelector('canvas, #scope, #canvas');
  if(!cvs){ console.warn('canvasが見つかりません'); return; }
  const dpr = window.devicePixelRatio || 1;

  // A/B/Δtの簡易表示（既存UIがあれば無視されます）
  let pane = document.getElementById('abdt-pane');
  if(!pane){
    pane = document.createElement('div');
    pane.id='abdt-pane';
    pane.style.cssText='position:fixed;left:10px;bottom:10px;background:rgba(0,0,0,.55);'+
      'color:#C7F564;padding:6px 8px;border-radius:8px;font:12px/1.3 system-ui;z-index:99999';
    pane.innerHTML='<span id="kvA_q">A: --.-- s</span>　'+
                   '<span id="kvB_q">B: --.-- s</span>　'+
                   '<span id="kvD_q">Δt: --.-- s</span>';
    document.body.appendChild(pane);
  }
  const kvA=document.getElementById('kvA_q')||pane.querySelector('#kvA_q');
  const kvB=document.getElementById('kvB_q')||pane.querySelector('#kvB_q');
  const kvD=document.getElementById('kvD_q')||pane.querySelector('#kvD_q');

  // AudioContext / analyser を安全に参照（あなたの startMic のまま）
  function getAC(){ return window.ctx||window.audioCtx||window.AC||null; }
  function getAnalyser(){ return window.analyser||window._analyser||null; }

  // 画面に“今映っている”時間幅（秒）を推定：analyser の1バッファ=波形の横幅
  function currentWindowSec(){
    const ac = getAC(); const an = getAnalyser();
    const sr = (ac && ac.sampleRate) ? ac.sampleRate : 48000;
    const fft = (an && an.fftSize) ? an.fftSize : 2048;
    // 画面全幅に並べて描いている実装がほとんど。これでズレが出なくなる。
    return fft / sr;
  }

  // クリック位置→時間（秒）
  function clickToTimeSec(ev){
    const rect = cvs.getBoundingClientRect();
    // DPI補正（ズーム倍率もこれで吸収）
    const ratio = (cvs.width && rect.width) ? (cvs.width/rect.width) : (dpr);
    const x = (ev.clientX - rect.left) * ratio;
    const total = currentWindowSec();
    // 左端=0sec, 右端=totalSec として正確にマッピング
    return Math.max(0, Math.min(total, (x / (cvs.width||rect.width*ratio)) * total));
  }

  // A/B/Δt
  const pick = { A:null, B:null };
  function updatePane(){
    kvA.textContent = 'A: ' + (pick.A==null?'--.--':pick.A.toFixed(4)) + ' s';
    kvB.textContent = 'B: ' + (pick.B==null?'--.--':pick.B.toFixed(4)) + ' s';
    kvD.textContent = 'Δt: ' + ((pick.A!=null && pick.B!=null)? Math.abs(pick.B-pick.A).toFixed(4) : '--.--') + ' s';
  }

  // 左クリックで A→B→A… と入れ替え
  cvs.addEventListener('mousedown', (ev)=>{
    if(ev.button!==0) return;
    const t = clickToTimeSec(ev);
    if(pick.A==null) pick.A=t;
    else if(pick.B==null) pick.B=t;
    else { pick.A=t; pick.B=null; }
    updatePane();
    ev.preventDefault();
    ev.stopImmediatePropagation(); // 既存のズレたハンドラがあっても抑止
  }, true);

  // 右ドラッグのズームは“時間窓の計算”と一致しない実装が多いので、今回の緊急版では無効化（誤動作回避）
  // 必要ならここに正確ズーム版を後で入れる。

  // 単発インパルス（山1つ）
  window.playImpulse = async function(){
    let AC = getAC();
    if(!AC){ AC = new (window.AudioContext||window.webkitAudioContext)(); window.AC = AC; }
    if(AC.state==='suspended'){ try{ await AC.resume(); }catch(_){} }
    const sr = AC.sampleRate;
    const frames = Math.max(3, Math.floor(sr*0.002)); // 約2ms
    const buf = AC.createBuffer(1, frames, sr);
    const ch  = buf.getChannelData(0);
    ch[0] = 1.0; for(let i=1;i<frames;i++) ch[i]=0.0;
    const src = AC.createBufferSource();
    src.buffer = buf;
    src.connect(AC.destination);
    src.start();
  };

  // 実験用：⌘/Ctrl + I で即インパルス
  window.addEventListener('keydown', (e)=>{
    if((e.metaKey||e.ctrlKey) && (e.key==='i' || e.key==='I')){ try{ window.playImpulse(); }catch(_){} }
  });

  updatePane();
})();
</script>

</body>
</html>
